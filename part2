# Create tabs for different sections of the app
tab1, tab2, tab3 = st.tabs(["Overview", "Volatility Regimes", "Shock Simulation"])

# --- Overview Tab ---
with tab1:
    st.title("FX Volatility Thresholding: Manual vs. Hybrid Approach")
    st.markdown("""
    ### Why Move Beyond Manual Thresholds?

    **Manual Approach (Status Quo):** Risk teams often set **static volatility thresholds** based on historical averages or hard-coded rules. For example, currencies might be bucketed into volatility groups with fixed thresholds (e.g., Group 1: threshold 0.10, Group 2: 0.40, Group 3: 0.70, Group 4: 1.30 based on increasing vol). Once set, these limits remain the same regardless of market changes.

    **Problems with Static Thresholds:**  
    - *No Adaptation:* A fixed threshold **doesn't adjust** when market volatility shifts up or down, so it can trigger too many alerts in calm periods and fail to catch risk in turbulent periods. [oai_citation:8‡logicmonitor.com](https://www.logicmonitor.com/blog/static-thresholds-vs-dynamic-thresholds#:~:text=Image%3A%20Checkmark)  
    - *Blind Spots:* Sudden volatility spikes (e.g. during an event) will **breach the threshold unexpectedly**, because it was set assuming a calmer regime. Conversely, if the market quiets down significantly, the static threshold might be too high to flag anything (missing subtle warnings).  
    - *One-Size-Fits-All:* Static rules often ignore context. What’s normal for one currency or regime may be high-risk for another. Without regime context, the threshold can misclassify normal variation as abnormal or vice versa.

    **Our Hybrid Dynamic Approach:**  
    - **Regime Detection (HMM):** We first identify volatility regimes (e.g. *Calm*, *Normal*, *Stress*) from historical data using an HMM model. This provides context: for instance, if we are in a *High Volatility* regime, we expect a higher normal volatility level.  
    - **Rolling Quantile Threshold:** Instead of a fixed number, the alert threshold is set to a high percentile (e.g. 95th percentile) of recent volatility. This means it **automatically rises or falls** with the recent volatility trend [oai_citation:9‡logicmonitor.com](https://www.logicmonitor.com/blog/static-thresholds-vs-dynamic-thresholds#:~:text=Dynamic%20thresholds%20offer%20a%20more,time%20data%2C%20reducing%20unnecessary%20alerts), reducing the noise of false alarms when markets are calm and catching true spikes when markets get noisy.  
    - **Extreme Value Calibration (EVT):** For additional safety, we calibrate an extreme threshold using Extreme Value Theory on volatility shocks. This gives an upper bound for extreme moves (e.g. ~99th percentile), ensuring that even tail-risk events are recognized.  
    - **Blend with Business Rules:** The dynamic model can be combined with expert input – for example, using the HMM regime to inform if human override is needed or to adjust the sensitivity.

    **Business Value of Dynamic Thresholding:**  
    - *Fewer False Alarms:* By adapting to market conditions in real-time, dynamic thresholds **reduce alert fatigue** – the system doesn't cry wolf when nothing truly abnormal is happening [oai_citation:10‡logicmonitor.com](https://www.logicmonitor.com/blog/static-thresholds-vs-dynamic-thresholds#:~:text=Manually%20adjusting%20the%20threshold%20takes,missing%20out%20on%20true%20positives). In tests, adaptive models have shown far fewer false alerts than fixed thresholds [oai_citation:11‡ieee-security.org](https://www.ieee-security.org/TC/SP2012/posters/An%20Extreme%20Value%20Theory%20Approach.pdf#:~:text=%28EVT,related%20problems).  
    - *Timely Alerts:* When volatility truly breaks out of the recent range, the system catches it immediately (often faster than a manually adjusted threshold would). This helps risk managers respond quicker to market shocks.  
    - *Explainability:* Every alert can be explained with context: _\"Volatility hit 1.1, which is above the 95th percentile for the last 90 days (threshold 1.0) while in a High Vol regime, hence an alert.\"_ This traceability builds trust that alerts are **data-driven and contextual**, not arbitrary.
    """)

# --- Volatility Regimes Tab ---
with tab2:
    st.header(f"Volatility Regimes for {selected_ccy}")
    # Plot volatility time series colored by regime
    fig = px.scatter(dfc, x='Date', y='DailyVol', color='RegimeName',
                     title=f"{selected_ccy}: Daily Volatility by Regime",
                     labels={"DailyVol": "Daily Volatility", "RegimeName": "Regime"})
    fig.update_traces(marker=dict(size=5))
    fig.update_layout(legend_title_text="Regime",
                      xaxis_title=None, yaxis_title="Daily Volatility")
    st.plotly_chart(fig, use_container_width=True)

    # Add an interpretation note
    st.markdown(f"""
    *Interpretation:* The chart above shows **volatility regimes** detected by our model for **{selected_ccy}**. 
    Each point is a day of trading, colored by the regime (blue = Low Vol, green = Medium, red = High Vol). 
    Notice how periods of sustained high volatility (red) tend to coincide with known market stress events or news. 
    In those periods, our threshold model would expect a higher normal volatility level. 
    During calm regimes (blue), volatility is low and stable, so a much lower threshold is warranted. 
    This regime context helps explain why the alert threshold changes over time.
    """)

    # Optional: Show static vs dynamic threshold on a recent subset for comparison
    last_year = dfc[dfc['Date'] >= (dfc['Date'].max() - pd.DateOffset(years=1))]
    thresh_fig = go.Figure()
    thresh_fig.add_trace(go.Scatter(x=last_year['Date'], y=last_year['DailyVol'], 
                                    mode='lines', name='Daily Volatility'))
    thresh_fig.add_trace(go.Scatter(x=last_year['Date'], y=last_year['DynamicThreshold'], 
                                    mode='lines', name='Dynamic Threshold (95%ile)', line=dict(color='orange', dash='dash')))
    thresh_fig.add_hline(y=manual_threshold, line_color='red', line_dash='dot',
                         annotation_text="Manual Threshold", annotation_position="bottom right")
    thresh_fig.update_layout(title="Static vs Dynamic Threshold (Recent Year)",
                             yaxis_title="Volatility", xaxis_title=None)
    st.plotly_chart(thresh_fig, use_container_width=True)
    st.markdown(f"""
    In the above comparison, the **red dotted line** is the fixed manual threshold (for {selected_ccy}), and the **orange dashed line** is the dynamic 95% quantile threshold evolving over the past year. 
    You can see that in quiet periods, the dynamic threshold is lower (tightening alert criteria), whereas the static threshold stays flat (potentially too high to trigger any warning). 
    When volatility rises, the dynamic threshold increases in response, but with a slight lag, ensuring only persistent departures trigger alerts. 
    The static threshold, however, either triggers a flood of alerts if set too low, or misses the event if set too high. 
    """)

# --- Shock Simulation & Recalibration Tab ---
with tab3:
    st.header("Simulate a Volatility Shock")
    st.write("Use the controls below to simulate a sudden volatility shock and see how thresholds adjust:")

    # User inputs for shock scenario
    snap_date = st.date_input("Baseline Date (Pre-Shock)", value=pd.to_datetime(dfc['Date'].iloc[-100]), 
                               min_value=dfc["Date"].min(), max_value=dfc["Date"].max())
    shock_start = st.date_input("Shock Start Date", value=pd.to_datetime(dfc['Date'].iloc[-90]))
    shock_end   = st.date_input("Shock End Date", value=pd.to_datetime(dfc['Date'].iloc[-30]))
    shock_mag   = st.slider("Shock Magnitude (multiplicative factor on volatility)", 
                             min_value=1.0, max_value=5.0, value=2.0, step=0.1)

    # Apply shock to volatility for the specified period
    sim_df = dfc.copy()
    mask = (sim_df['Date'] >= pd.to_datetime(shock_start)) & (sim_df['Date'] <= pd.to_datetime(shock_end))
    sim_df['Vol_Shocked'] = sim_df['DailyVol'].copy()
    sim_df.loc[mask, 'Vol_Shocked'] = sim_df.loc[mask, 'DailyVol'] * shock_mag

    # Recompute dynamic thresholds on the shocked data
    sim_df['DynThreshold_Shocked'] = rolling_quantile(sim_df['Vol_Shocked'], window, quantile_level)
    evt_threshold_shocked = garch_evt(sim_df['LogReturn'], tail_pct=0.990)

    # Get threshold values at snapshot date (just before shock) and after shock
    baseline_dyn_thresh = sim_df[sim_df['Date'] <= snap_date]['DynThreshold_Shocked'].iloc[-1]
    postshock_dyn_thresh = sim_df['DynThreshold_Shocked'].iloc[-1]
    manual_threshold_baseline = sim_df[sim_df['Date'] <= snap_date]['DailyVol'].mean()

    # Display key threshold values for comparison
    col1, col2, col3 = st.columns(3)
    col1.metric("Manual Threshold (pre-shock)", f"{manual_threshold_baseline:.4f}")
    col2.metric("Dynamic Threshold (pre-shock)", f"{baseline_dyn_thresh:.4f}")
    col3.metric("Dynamic Threshold (post-shock)", f"{postshock_dyn_thresh:.4f}", 
                delta=f"{(postshock_dyn_thresh-baseline_dyn_thresh):.4f}")

    st.markdown(f"*Before the shock*, the manual threshold for {selected_ccy} was ~**{manual_threshold_baseline:.2f}** (red line), and our dynamic threshold about **{baseline_dyn_thresh:.2f}**. 
                After introducing the shock (x{shock_mag:.1f} volatility from {shock_start} to {shock_end}), the adaptive threshold automatically **recalibrated** to **{postshock_dyn_thresh:.2f}**, shown in green above. 
                (The manual threshold would have stayed at {manual_threshold_baseline:.2f}, far below the new volatility level.)")

    # Plot the original vs shocked volatility and threshold
    shock_fig = go.Figure()
    shock_fig.add_trace(go.Scatter(x=sim_df['Date'], y=sim_df['DailyVol'], name="Original Volatility"))
    shock_fig.add_trace(go.Scatter(x=sim_df['Date'], y=sim_df['Vol_Shocked'], name=f"Shocked Vol (x{shock_mag})", line=dict(color='royalblue')))
    shock_fig.add_hline(y=baseline_dyn_thresh, line_dash="dot", line_color="orange",
                        annotation_text="Pre-Shock Dyn Threshold", annotation_position="bottom right")
    shock_fig.add_hline(y=postshock_dyn_thresh, line_dash="dash", line_color="green",
                        annotation_text="Post-Shock Dyn Threshold", annotation_position="top right")
    shock_fig.add_hline(y=manual_threshold_baseline, line_dash="dash", line_color="red",
                        annotation_text="Manual Threshold", annotation_position="bottom left")
    shock_fig.add_vrect(x0=shock_start, x1=shock_end, fillcolor="red", opacity=0.1, 
                        annotation_text="Shock Period", line_width=0)
    shock_fig.update_layout(title=f"{selected_ccy} Volatility Shock Simulation", 
                             yaxis_title="Volatility", xaxis_title=None)
    st.plotly_chart(shock_fig, use_container_width=True)

    st.markdown(f"""
    **Outcome:** In the chart above, the red shaded area represents the simulated shock period where volatility was artificially multiplied. 
    The **green dashed line** shows how our dynamic threshold jumped from {baseline_dyn_thresh:.2f} to {postshock_dyn_thresh:.2f} in reaction to the shock, entering a new high-volatility regime. 
    The **orange dotted line** was the threshold before the shock. 
    Notice that the **manual threshold (red dash)** stayed at {manual_threshold_baseline:.2f} throughout – it would have been far too low during the shock, triggering continuous alerts. 
    Our hybrid approach, however, adjusted its threshold upward, signaling a regime shift. After the shock passes, if volatility falls, the threshold will likewise ease down, ensuring that as conditions normalize, the sensitivity increases again. 

    This dynamic recalibration is crucial during **market shocks**: it provides immediate flexibility, whereas a static system would have required manual reconfiguration (and might generate numerous false positives in the meantime). 
    The result is a more resilient alerting system that maintains **high precision and timely detection** even as market volatility evolves.
    """)
