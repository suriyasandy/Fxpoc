import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from hmmlearn.hmm import GaussianHMM
from arch import arch_model
from scipy.stats import genpareto
import itertools

# Constants
SQRT252 = np.sqrt(252)
MANUAL_BANDS = {
    'Group 1': (0.00, 0.07),
    'Group 2': (0.07, 0.50),
    'Group 3': (0.50, 0.60),
    'Group 4': (0.60, None)
}

# Manual group assignment
def assign_manual_group(daily_vol):
    for group, (low, high) in MANUAL_BANDS.items():
        if high is None and daily_vol >= low:
            return group
        elif low <= daily_vol < high:
            return group
    return None

# Manual threshold lookup from grouped bands
def get_manual_thresholds(df):
    df['DailyVol'] = df['OHLCVolatility'] / SQRT252
    avg_vol = df.groupby('Currency')['DailyVol'].mean().reset_index()
    avg_vol['Group'] = avg_vol['DailyVol'].apply(assign_manual_group)

    thresholds = avg_vol.groupby('Group')['DailyVol'].max().reset_index()
    thresholds.columns = ['Group', 'Threshold']
    return avg_vol, thresholds

# Build cross currency pairs from base currency data
def build_cross_pairs(df):
    close_pivot = df.pivot(index='Date', columns='Currency', values='Close')
    vol_pivot = df.pivot(index='Date', columns='Currency', values='OHLCVolatility') / SQRT252
    cross_data = []

    for base in close_pivot.columns:
        for quote in close_pivot.columns:
            if base != quote:
                cross_name = f"{base}/{quote}"
                try:
                    rate = close_pivot[base] / close_pivot[quote]
                    vol = np.sqrt(vol_pivot[base]**2 + vol_pivot[quote]**2)
                    lr = np.log(rate / rate.shift(1))
                    cross_df = pd.DataFrame({
                        'Date': rate.index,
                        'Cross': cross_name,
                        'Close': rate,
                        'DailyVol': vol,
                        'LogReturn': lr
                    }).dropna()
                    cross_data.append(cross_df)
                except:
                    continue
    return pd.concat(cross_data, ignore_index=True)

# GARCH + EVT model to get tail threshold
def garch_evt(returns, tail_pct=0.99):
    am = arch_model(returns*100, vol='Garch', p=1, q=1)
    res = am.fit(disp='off')
    std = (res.resid / res.conditional_volatility).dropna()
    threshold = np.quantile(std, 0.90)
    excess = std[std > threshold] - threshold
    if len(excess) < 5:
        return np.nan
    c, loc, scale = genpareto.fit(excess, floc=0)
    var = genpareto.ppf((tail_pct - (1 - (std > threshold).mean())) / (std > threshold).mean(), c, loc=0, scale=scale)
    return (threshold + var) / 100.0
