# app.py

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from arch import arch_model
from scipy.stats import genpareto
from hmmlearn.hmm import GaussianHMM
import datetime

st.set_page_config(page_title="FX Thresholding App", layout="wide")

# ---------------------
# Utility Functions
# ---------------------
def rolling_quantile(vol, window, q):
    return vol.rolling(window).quantile(q)

def garch_evt(returns, tail_pct):
    am = arch_model(returns * 100, vol='Garch', p=1, q=1)
    res = am.fit(disp='off')
    std = res.resid / res.conditional_volatility
    std = std[~np.isnan(std)]
    u = np.quantile(std, 0.90)
    exc = std[std > u] - u
    c, loc, scale = genpareto.fit(exc, floc=0)
    p_exc = (tail_pct - (1 - np.mean(std > u))) / np.mean(std > u)
    var = genpareto.ppf(p_exc, c, loc=0, scale=scale)
    return (u + var) / 100.0

def detect_regimes(vol, n_states):
    model = GaussianHMM(n_components=n_states, covariance_type='full', n_iter=200)
    arr = vol.values.reshape(-1, 1)
    model.fit(arr)
    states = model.predict(arr)
    means = {s: arr[states == s].mean() for s in np.unique(states)}
    return states, max(means, key=means.get), means

# ---------------------
# Sidebar - Upload & Settings
# ---------------------
st.sidebar.header("Upload & Settings")
f = st.sidebar.file_uploader("Upload CSV (Date,Open,High,Low,Close,OHLCVolatility,Currency)", type="csv")
if not f:
    st.sidebar.info("Awaiting FX dataâ€¦")
    st.stop()

df = pd.read_csv(f, parse_dates=['Date']).sort_values('Date')
df['DailyVol'] = df['OHLCVolatility'] / np.sqrt(252)

# Currency selector
currencies = sorted(df['Currency'].unique())
selected_ccy = st.sidebar.selectbox("Select Currency", currencies)

# ---------------------
# Data Preparation
# ---------------------
dfc = df[df['Currency'] == selected_ccy].copy().reset_index(drop=True)
dfc['LogReturn'] = np.log(dfc['Close'] / dfc['Close'].shift(1))
dfc = dfc.dropna()
dfc['Date'] = pd.to_datetime(dfc['Date'])

# Regime detection
states, high_regime, regime_means = detect_regimes(dfc['DailyVol'], n_states=3)
dfc['Regime'] = states

# ---------------------
# Tabs Definition
# ---------------------
tab1, tab2, tab3 = st.tabs(["ðŸ“‹ Overview", "ðŸ“Š Regimes & Thresholds", "ðŸš€ Shock Simulation"])

# ---------------------
# Overview Tab
# ---------------------
with tab1:
    st.title("FX Thresholding: Manual vs Hybrid Approach")
    st.markdown("""
    **Manual Thresholds** are based on grouping currencies by their historical average 1-year daily volatility:
    - Group 1 (Low): Avg ~0.04 â†’ Thr = 0.10
    - Group 2 (Medium): Avg ~0.33 â†’ Thr = 0.40
    - Group 3 (High): Avg ~0.64 â†’ Thr = 0.70
    - Group 4 (Very High): Avg ~1.25 â†’ Thr = 1.30

    These **static** thresholds never adapt to new market shocks, leading to missed alerts or false alarms.

    **Hybrid Dynamic Approach**:
    - **Regime-Aware**: HMM splits into Calm/Normal/Stress states.
    - **Per-Regime Calibration**: Rolling 95th percentile + EVT tail per state.
    - **Shock Recalibration**: Instantly updates thresholds post-shock.

    > *Example*: Manual Thr = 0.70 (OctÂ 14). After a simulated shock on OctÂ 15â€“NovÂ 30, Hybrid Thr adjusts to 1.08, reflecting true market risk.
    """)

# ---------------------
# Regimes & Thresholds Tab
# ---------------------
with tab2:
    st.header(f"Volatility Regimes & Thresholds â€” {selected_ccy}")
    # Regime scatter
    fig = px.scatter(dfc, x='Date', y='DailyVol', color='Regime',
                     title=f"{selected_ccy} Daily Volatility by Regime", height=400)
    st.plotly_chart(fig, use_container_width=True)

    # Compute static manual threshold up to last date
    manual_thr_static = dfc['DailyVol'].mean()

    # Compute dynamic alert EVT for whole period as example
    window = 90
    dyn_alert = rolling_quantile(dfc['DailyVol'], window, 0.95).iloc[-1]
    dyn_evt = garch_evt(dfc['LogReturn'], tail_pct=0.99)

    cols = st.columns(3)
    cols[0].metric("Manual Thr (1yr avg)", f"{manual_thr_static:.4f}")
    cols[1].metric("Dynamic Alert Thr (95%)", f"{dyn_alert:.4f}")
    cols[2].metric("Dynamic EVT Thr", f"{dyn_evt:.4f}")

# ---------------------
# Shock Simulation Tab
# ---------------------
with tab3:
    st.header("Shock Simulation & Recalibration")

    # Snapshot date up to dataset max minus one day
    snap_date = st.date_input("Snapshot Date (pre-shock)", value=dfc['Date'].max() - pd.Timedelta(days=1),
                              min_value=dfc['Date'].min(), max_value=dfc['Date'].max() - pd.Timedelta(days=1))
    snap_date = pd.to_datetime(snap_date)

    # Shock period
    shock_start = st.date_input("Shock Start Date", value=snap_date + pd.Timedelta(days=1),
                                min_value=snap_date + pd.Timedelta(days=1), max_value=dfc['Date'].max())
    shock_end = st.date_input("Shock End Date", value=dfc['Date'].max(),
                              min_value=shock_start, max_value=dfc['Date'].max())

    # Shock magnitude slider
    shock_mag = st.slider("Shock Magnitude (Ã— real vol)", 1.0, 5.0, 2.0, step=0.1)

    # Apply shock
    dfc['ShockedVol'] = dfc['DailyVol']
    mask = (dfc['Date'] >= pd.to_datetime(shock_start)) & (dfc['Date'] <= pd.to_datetime(shock_end))
    dfc.loc[mask, 'ShockedVol'] *= shock_mag

    # Recompute thresholds post-shock
    post_alert = rolling_quantile(dfc['ShockedVol'], window, 0.95).iloc[-1]
    post_evt = garch_evt(dfc.loc[dfc['Date'] <= shock_end, 'LogReturn'], tail_pct=0.99)

    # Manual threshold frozen at snapshot
    manual_thr = dfc.loc[dfc['Date'] <= snap_date, 'DailyVol'].mean()

    # Display metrics comparison
    st.subheader("Threshold Comparison")
    df_metrics = pd.DataFrame({
        'Threshold Type': ['Manual (static)', 'Dynamic Alert', 'Dynamic EVT'],
        'Value': [manual_thr, post_alert, post_evt]
    }).set_index('Threshold Type')
    st.table(df_metrics)

    # Plot original vs shocked & thresholds
    fig2 = go.Figure()
    fig2.add_trace(go.Scatter(x=dfc['Date'], y=dfc['DailyVol'], name='Original Vol'))
    fig2.add_trace(go.Scatter(x=dfc['Date'], y=dfc['ShockedVol'], name='Shocked Vol', line=dict(color='blue')))
    fig2.add_hline(y=manual_thr, line_dash='dash', line_color='green', annotation_text='Manual Thr', annotation_position='bottom right')
    fig2.add_hline(y=post_alert, line_dash='dot', line_color='red', annotation_text='Dynamic Alert Thr')
    fig2.add_hline(y=post_evt, line_dash='longdash', line_color='purple', annotation_text='Dynamic EVT Thr')
    fig2.add_vrect(x0=shock_start, x1=shock_end, fillcolor='red', opacity=0.2, layer='below',
                   annotation_text='Shock Period', annotation_position='top left')
    fig2.update_layout(title="Volatility Trend & Shock Simulation", yaxis_title="Daily Volatility", height=450)
    st.plotly_chart(fig2, use_container_width=True)
